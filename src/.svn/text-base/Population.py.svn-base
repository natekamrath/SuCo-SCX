import ParentSelection
import SurvivorSelection
import Crossover
import Mutation
import GeneTypes
import Util
import sys
import math
import random
from itertools import combinations

class Individual(object):
    def __init__(self, genes=[], id=None, crossover=None, fitness= -sys.maxint - 1):
        self.genes = genes
        self.crossover = crossover
        self.fitness = fitness
        self.id = id
        self.parents = (None, None)
    def distance(self, other):
        return math.sqrt(sum([(mine - theirs) ** 2 for mine, theirs in zip(self.genes, other.genes)]))
    def getFit(self):
        return self.fitness
    def __cmp__(self, other):
        return 1 if self.fitness > other.fitness else -1 if self.fitness < other.fitness else 0
    def __str__(self):
        return "(" + ",".join(map(str, self.genes)) + ") = " + str(self.fitness)
    def __repr__(self):
        return str(self)
    def __hash__(self):
        return int("".join(map(str, self.genes)), 2)

class Population(object):
    def __init__(self, constants):
        self.geneType = Util.moduleClasses(GeneTypes)[constants["geneType"]](constants["min"], constants["max"])
        self.individuals = []
        try: self.parentSelection = Util.moduleFunctions(ParentSelection)[constants["parentSelection"]]
        except KeyError: pass
        try: self.crossover = Util.moduleFunctions(Crossover)[constants["crossover"]]
        except KeyError: pass
        try: self.mutation = Util.moduleFunctions(Mutation)[constants["mutation"]]
        except KeyError: pass
        try: self.survivorSelection = Util.moduleFunctions(SurvivorSelection)[constants["survivorSelection"]]
        except KeyError: pass
        self.next = self.generator(constants).next
        self.id = None

    def initialIndividuals(self, constants):
        for i in range(constants["popSize"]):
            if "initialCrossoverLength" in constants:
                cross = Crossover.Crossover(constants["initialCrossoverLength"])
            else:
                cross = None
            individual = Individual(self.geneType.randomGenome(constants["dimensions"]), i, cross)
            self.id = i
            yield individual
            self.individuals.append(individual)

    def generator(self, constants):
        for individual in self.initialIndividuals(constants):
            yield individual

        while True:
            parents = self.parentSelection(self.individuals, constants["offSize"] * constants["parentsPerChild"], constants)
            for i in range(0, len(parents), constants["parentsPerChild"]):
                family = parents[i:i + constants["parentsPerChild"]]
                child = Individual(id=id)
                child.parents = [parent.id for parent in family]
                self.id += 1
                self.crossover(child, family, constants)
                self.mutation(child, constants, family)
                self.geneType.fix(child.genes)
                yield child
                self.individuals.append(child)
            self.individuals = self.survivorSelection(self.individuals, constants["popSize"], constants)

class CoPopulation(Population):
    def evalPop(self, constants):
        # reset all of the individuals
        for individual in self.individuals:
            individual.fitness = 0
            individual.evalCount = 0
        # all individuals are valid to choose at the start
        valid = range(len(self.individuals))
        # keep going until no one is valid
        while(len(valid) > 0):
            choice = random.choice(valid)
            # if this individual needs more evaluations
            if self.individuals[choice].evalCount < constants["evalsPerGeneration"]:
                # store the current fitness
                fitness = self.individuals[choice].fitness
                yield self.individuals[choice]
            else:
                valid.remove(choice)

    def generator(self, constants):
        for _ in self.initialIndividuals(constants):
            pass
        for individual in self.evalPop(constants):
            yield individual
        while True:
            parents = self.parentSelection(self.individuals, constants["offSize"] * constants["parentsPerChild"], constants)
            for i in range(0, len(parents), constants["parentsPerChild"]):
                family = parents[i:i + constants["parentsPerChild"]]
                child = Individual(id=id)
                child.parents = [parent.id for parent in family]
                self.id += 1
                self.crossover(child, family, constants)
                self.mutation(child, constants, family)
                self.geneType.fix(child.genes)
                self.individuals.append(child)
            for individual in self.evalPop(constants):
                yield individual
            self.individuals = self.survivorSelection(self.individuals, constants["popSize"], constants)

class Primary(Population):
    def generator(self, constants, support=None):
        supportIndividual = None
        for individual in self.initialIndividuals(constants):
            if constants["SuCoLevel"] == "SA":
                # TODO Explain ranging
                SAfix = GeneTypes.FLT(0.001, constants["mutationStepSize"])
                individual.stepSizes = SAfix.randomGenome(constants["dimensions"])
            yield individual, None

        while True:
            parents = self.parentSelection(self.individuals, constants["offSize"] * constants["parentsPerChild"], constants)
            for i in range(0, len(parents), constants["parentsPerChild"]):
                family = parents[i:i + constants["parentsPerChild"]]

                child = Individual(id=id)
                child.parents = [parent for parent in family]
                self.id += 1
                self.crossover(child, family, constants)
                if constants["SuCoLevel"] == 'Support':
                    supportIndividual = support()
                    rates = supportIndividual.genes
                elif constants["SuCoLevel"] == 'SA':
                    bias = 1 / math.sqrt(2.0 * constants["dimensions"]) * random.gauss(0, 1)
                    tau = 1 / math.sqrt(2.0 * math.sqrt(constants["dimensions"]))
                    child.stepSizes = [(sum(psteps) / len(psteps)) * math.exp(bias + tau * random.gauss(0, 1)) for psteps in zip(*[f.stepSizes for f in family])]
                    SAfix.fix(child.stepSizes)
                    rates = child.stepSizes
                elif constants["SuCoLevel"] == "Static":
                    rates = constants["stepSizes"]
                self.mutation(child, constants, rates)
                self.geneType.fix(child.genes)
                yield child, supportIndividual
                self.individuals.append(child)

            self.individuals = self.survivorSelection(self.individuals, constants["popSize"], constants)

class SuCo(Population):
    def generator(self, constants):
        if constants["SuCoLevel"] == "Support":
            supportConstants = dict(constants)
            supportConstants["max"] = constants["mutationStepSize"]
            supportConstants["min"] = 0.001
            supportConstants["mutation"] = "tau"
            for key, value in constants.iteritems():
                if 'support_' in key:
                    supportConstants[key.lstrip("support_")] = value
            popType = CoPopulation if "reeval" in constants["SuCoFitnessDecorators"] else Population
            if "joined" in constants["SuCoFitnessDecorators"]:
                support = [popType(supportConstants).generator(supportConstants).next] * constants["parallelPopulations"]
            else:
                support = [popType(supportConstants).generator(supportConstants).next for _ in range(constants["parallelPopulations"])]
        else:
            support = [None] * constants["parallelPopulations"]
        primaries = [Primary(constants).generator(constants, supportPop).next for supportPop in support]
        while True:
            for p in primaries:
                child, supportIndividual = p()
                yield child
                family = child.parents
                if constants["SuCoLevel"] == "Support" and supportIndividual is not None:
                    fitness = child.fitness
                    if "relative" in constants["SuCoFitnessDecorators"]:
                        fitness -= (sum([p.fitness for p in family]) / len(family))
                    if "distance" in constants["SuCoFitnessDecorators"]:
                        pdist = family[0].distance(family[1])
                        if pdist < 1: pdist = 1
                        if pdist != 0:
                            fitness *= (child.distance(family[0]) * child.distance(family[1])) / pdist
                    supportIndividual.fitness += fitness
                    try: supportIndividual.evalCount += 1
                    except: supportIndividual.evalCount = 1
